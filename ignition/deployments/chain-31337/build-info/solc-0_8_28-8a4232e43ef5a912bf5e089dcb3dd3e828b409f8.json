{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-8a4232e43ef5a912bf5e089dcb3dd3e828b409f8",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Factory.sol": "project/contracts/Factory.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/core/LiquidityPool.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"../tokens/LPToken.sol\";\nimport \"../tokens/ERC20Base.sol\";\n\n/**\n * @title LiquidityPool\n * @notice AMM (Automated Market Maker) pool using constant product formula\n * @dev Implements x * y = k formula like Uniswap V1/V2\n *\n * ============ HOW AN AMM WORKS ============\n *\n * Traditional exchanges use ORDER BOOKS (buyers and sellers set prices).\n * AMMs use a MATHEMATICAL FORMULA to determine prices automatically!\n *\n * THE FORMULA: x * y = k (constant product)\n * - x = amount of token0 in the pool\n * - y = amount of token1 in the pool\n * - k = constant (stays the same after every swap)\n *\n * EXAMPLE:\n * Pool has: 100 ETH (x) and 200,000 USDC (y)\n * k = 100 * 200,000 = 20,000,000\n *\n * Someone wants to buy ETH with 1,000 USDC:\n * - New y = 200,000 + 1,000 = 201,000 USDC\n * - k must stay 20,000,000\n * - New x = k / new y = 20,000,000 / 201,000 = 99.502... ETH\n * - ETH out = 100 - 99.502 = 0.498 ETH\n *\n * Notice: They got ~0.498 ETH for 1,000 USDC\n * That's about 2,008 USDC per ETH (price moved!)\n * This is called PRICE IMPACT - larger trades move the price more.\n *\n * ============ FEES ============\n *\n * We charge a 0.3% fee on swaps (like Uniswap).\n * This fee stays in the pool and benefits LP holders.\n * Over time, k actually INCREASES due to fees collected.\n *\n * ============ SLIPPAGE PROTECTION ============\n *\n * Because prices move during swaps, users specify a \"minAmountOut\".\n * If they would receive less than this, the transaction reverts.\n * This protects against front-running and large price movements.\n */\ncontract LiquidityPool {\n    // ============ State Variables ============\n\n    /// @notice First token in the pair\n    ERC20Base public token0;\n\n    /// @notice Second token in the pair\n    ERC20Base public token1;\n\n    /// @notice LP token for this pool\n    LPToken public lpToken;\n\n    /// @notice Current reserve of token0 in the pool\n    uint256 public reserve0;\n\n    /// @notice Current reserve of token1 in the pool\n    uint256 public reserve1;\n\n    /// @notice Swap fee in basis points (30 = 0.3%)\n    /// @dev Basis points: 10000 = 100%, so 30 = 0.3%\n    uint256 public constant FEE_BPS = 30;\n\n    /// @notice Minimum liquidity locked forever to prevent division by zero\n    /// @dev When first LP adds liquidity, this amount is \"burned\"\n    uint256 public constant MINIMUM_LIQUIDITY = 1000;\n\n    // ============ Events ============\n\n    /// @notice Emitted when liquidity is added\n    event LiquidityAdded(\n        address indexed provider,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 lpTokensMinted\n    );\n\n    /// @notice Emitted when liquidity is removed\n    event LiquidityRemoved(\n        address indexed provider,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 lpTokensBurned\n    );\n\n    /// @notice Emitted when a swap occurs\n    event Swap(\n        address indexed user,\n        address indexed tokenIn,\n        uint256 amountIn,\n        address indexed tokenOut,\n        uint256 amountOut\n    );\n\n    // ============ Constructor ============\n\n    /**\n     * @notice Create a new liquidity pool\n     * @param _token0 Address of first token\n     * @param _token1 Address of second token\n     * @param _lpName Name for the LP token\n     * @param _lpSymbol Symbol for the LP token\n     */\n    constructor(\n        address _token0,\n        address _token1,\n        string memory _lpName,\n        string memory _lpSymbol\n    ) {\n        require(_token0 != address(0) && _token1 != address(0), \"Pool: zero address\");\n        require(_token0 != _token1, \"Pool: identical tokens\");\n\n        token0 = ERC20Base(_token0);\n        token1 = ERC20Base(_token1);\n\n        // Deploy the LP token - this pool becomes the \"pool\" in LPToken\n        lpToken = new LPToken(_lpName, _lpSymbol);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get current reserves\n     * @return _reserve0 Amount of token0 in pool\n     * @return _reserve1 Amount of token1 in pool\n     */\n    function getReserves() external view returns (uint256 _reserve0, uint256 _reserve1) {\n        return (reserve0, reserve1);\n    }\n\n    /**\n     * @notice Calculate output amount for a swap (before fees)\n     * @param amountIn Amount of input token\n     * @param reserveIn Reserve of input token\n     * @param reserveOut Reserve of output token\n     * @return amountOut Amount of output token user will receive\n     *\n     * @dev Uses the constant product formula with 0.3% fee\n     *\n     * Math explanation:\n     * x * y = k (must stay constant)\n     * (x + amountIn * 0.997) * (y - amountOut) = k\n     *\n     * Solving for amountOut:\n     * amountOut = (y * amountIn * 0.997) / (x + amountIn * 0.997)\n     *\n     * We use basis points to avoid decimals:\n     * amountInWithFee = amountIn * (10000 - 30) = amountIn * 9970\n     */\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) public pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"Pool: insufficient input amount\");\n        require(reserveIn > 0 && reserveOut > 0, \"Pool: insufficient liquidity\");\n\n        // Apply 0.3% fee: multiply by 9970 (10000 - 30 bps)\n        uint256 amountInWithFee = amountIn * (10000 - FEE_BPS);\n\n        // Numerator: reserveOut * amountInWithFee\n        uint256 numerator = reserveOut * amountInWithFee;\n\n        // Denominator: reserveIn * 10000 + amountInWithFee\n        uint256 denominator = (reserveIn * 10000) + amountInWithFee;\n\n        // Calculate output amount\n        amountOut = numerator / denominator;\n    }\n\n    // ============ Liquidity Functions ============\n\n    /**\n     * @notice Add liquidity to the pool\n     * @param amount0Desired Amount of token0 to add\n     * @param amount1Desired Amount of token1 to add\n     * @return amount0 Actual amount of token0 added\n     * @return amount1 Actual amount of token1 added\n     * @return liquidity Amount of LP tokens minted\n     *\n     * @dev Users must approve this contract to spend their tokens first!\n     *\n     * For the FIRST deposit:\n     * - LP tokens = sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY\n     * - MINIMUM_LIQUIDITY is burned (sent to address(0)) to prevent manipulation\n     *\n     * For subsequent deposits:\n     * - Must add tokens in the same ratio as current reserves\n     * - LP tokens = min(amount0/reserve0, amount1/reserve1) * totalSupply\n     */\n    function addLiquidity(\n        uint256 amount0Desired,\n        uint256 amount1Desired\n    ) external returns (uint256 amount0, uint256 amount1, uint256 liquidity) {\n        require(amount0Desired > 0 && amount1Desired > 0, \"Pool: insufficient amounts\");\n\n        uint256 _totalSupply = lpToken.totalSupply();\n\n        if (_totalSupply == 0) {\n            // ========== FIRST LIQUIDITY PROVIDER ==========\n            // Initial LP tokens = sqrt(amount0 * amount1)\n            // This makes the initial price = amount1 / amount0\n            amount0 = amount0Desired;\n            amount1 = amount1Desired;\n\n            liquidity = sqrt(amount0 * amount1);\n            require(liquidity > MINIMUM_LIQUIDITY, \"Pool: insufficient initial liquidity\");\n\n            // Lock MINIMUM_LIQUIDITY forever by minting to address(1)\n            // This prevents the pool from being emptied completely\n            // and protects against certain attack vectors\n            lpToken.mint(address(1), MINIMUM_LIQUIDITY);\n            liquidity -= MINIMUM_LIQUIDITY;\n        } else {\n            // ========== SUBSEQUENT LIQUIDITY PROVIDERS ==========\n            // Must add in same ratio as current reserves\n\n            // Calculate optimal amount1 for given amount0\n            uint256 amount1Optimal = (amount0Desired * reserve1) / reserve0;\n\n            if (amount1Optimal <= amount1Desired) {\n                // Use amount0Desired and calculated amount1\n                amount0 = amount0Desired;\n                amount1 = amount1Optimal;\n            } else {\n                // Calculate optimal amount0 for given amount1\n                uint256 amount0Optimal = (amount1Desired * reserve0) / reserve1;\n                require(amount0Optimal <= amount0Desired, \"Pool: invalid amounts\");\n                amount0 = amount0Optimal;\n                amount1 = amount1Desired;\n            }\n\n            // Calculate LP tokens to mint proportionally\n            // liquidity = min(amount0/reserve0, amount1/reserve1) * totalSupply\n            uint256 liquidity0 = (amount0 * _totalSupply) / reserve0;\n            uint256 liquidity1 = (amount1 * _totalSupply) / reserve1;\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n        }\n\n        require(liquidity > 0, \"Pool: insufficient liquidity minted\");\n\n        // Transfer tokens from user to pool\n        // User must have called approve() on both tokens first!\n        token0.transferFrom(msg.sender, address(this), amount0);\n        token1.transferFrom(msg.sender, address(this), amount1);\n\n        // Update reserves\n        reserve0 += amount0;\n        reserve1 += amount1;\n\n        // Mint LP tokens to user\n        lpToken.mint(msg.sender, liquidity);\n\n        emit LiquidityAdded(msg.sender, amount0, amount1, liquidity);\n    }\n\n    /**\n     * @notice Remove liquidity from the pool\n     * @param lpAmount Amount of LP tokens to burn\n     * @return amount0 Amount of token0 returned\n     * @return amount1 Amount of token1 returned\n     *\n     * @dev Burns LP tokens and returns proportional share of both tokens.\n     * If you own 10% of LP tokens, you get 10% of each reserve.\n     */\n    function removeLiquidity(\n        uint256 lpAmount\n    ) external returns (uint256 amount0, uint256 amount1) {\n        require(lpAmount > 0, \"Pool: insufficient LP amount\");\n\n        uint256 _totalSupply = lpToken.totalSupply();\n\n        // Calculate proportional amounts\n        // Your share = lpAmount / totalSupply\n        amount0 = (lpAmount * reserve0) / _totalSupply;\n        amount1 = (lpAmount * reserve1) / _totalSupply;\n\n        require(amount0 > 0 && amount1 > 0, \"Pool: insufficient amounts returned\");\n\n        // Burn LP tokens from user\n        lpToken.burn(msg.sender, lpAmount);\n\n        // Update reserves\n        reserve0 -= amount0;\n        reserve1 -= amount1;\n\n        // Transfer tokens back to user\n        token0.transfer(msg.sender, amount0);\n        token1.transfer(msg.sender, amount1);\n\n        emit LiquidityRemoved(msg.sender, amount0, amount1, lpAmount);\n    }\n\n    // ============ Swap Functions ============\n\n    /**\n     * @notice Swap token0 for token1\n     * @param amountIn Amount of token0 to swap\n     * @param minAmountOut Minimum amount of token1 to receive (slippage protection)\n     * @return amountOut Actual amount of token1 received\n     *\n     * @dev User must approve this contract to spend token0 first!\n     */\n    function swap0For1(\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) external returns (uint256 amountOut) {\n        require(amountIn > 0, \"Pool: insufficient input amount\");\n\n        // Calculate output using AMM formula\n        amountOut = getAmountOut(amountIn, reserve0, reserve1);\n\n        // Slippage check - revert if output too low\n        require(amountOut >= minAmountOut, \"Pool: slippage exceeded\");\n\n        // Take input tokens from user\n        token0.transferFrom(msg.sender, address(this), amountIn);\n\n        // Give output tokens to user\n        token1.transfer(msg.sender, amountOut);\n\n        // Update reserves\n        reserve0 += amountIn;\n        reserve1 -= amountOut;\n\n        emit Swap(msg.sender, address(token0), amountIn, address(token1), amountOut);\n    }\n\n    /**\n     * @notice Swap token1 for token0\n     * @param amountIn Amount of token1 to swap\n     * @param minAmountOut Minimum amount of token0 to receive (slippage protection)\n     * @return amountOut Actual amount of token0 received\n     *\n     * @dev User must approve this contract to spend token1 first!\n     */\n    function swap1For0(\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) external returns (uint256 amountOut) {\n        require(amountIn > 0, \"Pool: insufficient input amount\");\n\n        // Calculate output using AMM formula\n        amountOut = getAmountOut(amountIn, reserve1, reserve0);\n\n        // Slippage check\n        require(amountOut >= minAmountOut, \"Pool: slippage exceeded\");\n\n        // Take input tokens from user\n        token1.transferFrom(msg.sender, address(this), amountIn);\n\n        // Give output tokens to user\n        token0.transfer(msg.sender, amountOut);\n\n        // Update reserves\n        reserve1 += amountIn;\n        reserve0 -= amountOut;\n\n        emit Swap(msg.sender, address(token1), amountIn, address(token0), amountOut);\n    }\n\n    // ============ Internal Helpers ============\n\n    /**\n     * @notice Calculate square root using Babylonian method\n     * @dev Used to calculate initial LP tokens: sqrt(amount0 * amount1)\n     */\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
      },
      "project/contracts/Factory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./core/LiquidityPool.sol\";\n\n/**\n * @title Factory\n * @notice Factory contract that creates and tracks liquidity pools\n * @dev Implements the Factory Pattern - a contract that creates other contracts\n *\n * ============ WHY USE A FACTORY? ============\n *\n * 1. SINGLE ENTRY POINT\n *    Instead of deploying pools manually, users go through one factory.\n *    This ensures all pools are created consistently.\n *\n * 2. POOL DISCOVERY\n *    The factory keeps track of all pools it created.\n *    Anyone can call getPool(tokenA, tokenB) to find the pool address.\n *\n * 3. PREVENT DUPLICATES\n *    Only ONE pool can exist for each token pair.\n *    getPool(A, B) and getPool(B, A) return the same pool.\n *\n * 4. STANDARDIZATION\n *    All pools created by this factory have the same code and behavior.\n *\n * This is how Uniswap, SushiSwap, and most DEXes work!\n */\ncontract Factory {\n    // ============ State Variables ============\n\n    /// @notice Mapping from token pair to pool address\n    /// @dev pools[token0][token1] = pool address\n    /// We always store with token0 < token1 to ensure consistency\n    mapping(address => mapping(address => address)) public pools;\n\n    /// @notice Array of all pool addresses created by this factory\n    address[] public allPools;\n\n    // ============ Events ============\n\n    /// @notice Emitted when a new pool is created\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        address pool,\n        uint256 poolIndex\n    );\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get the number of pools created\n     * @return The total number of pools\n     */\n    function allPoolsLength() external view returns (uint256) {\n        return allPools.length;\n    }\n\n    /**\n     * @notice Get the pool address for a token pair\n     * @param tokenA First token address\n     * @param tokenB Second token address\n     * @return pool The pool address (or address(0) if no pool exists)\n     *\n     * @dev Order doesn't matter - getPool(A,B) == getPool(B,A)\n     */\n    function getPool(address tokenA, address tokenB) external view returns (address pool) {\n        // Sort tokens to ensure consistent lookup\n        (address token0, address token1) = _sortTokens(tokenA, tokenB);\n        return pools[token0][token1];\n    }\n\n    // ============ Pool Creation ============\n\n    /**\n     * @notice Create a new liquidity pool for a token pair\n     * @param tokenA First token address\n     * @param tokenB Second token address\n     * @return pool The address of the newly created pool\n     *\n     * @dev This deploys a new LiquidityPool contract.\n     * Only one pool can exist per token pair.\n     *\n     * HOW THIS WORKS:\n     * 1. Sort tokens (lower address becomes token0)\n     * 2. Check no pool exists yet\n     * 3. Deploy new LiquidityPool contract using \"new\" keyword\n     * 4. Store the pool address in mappings\n     * 5. Emit event\n     */\n    function createPool(address tokenA, address tokenB) external returns (address pool) {\n        // Validation\n        require(tokenA != tokenB, \"Factory: identical tokens\");\n        require(tokenA != address(0) && tokenB != address(0), \"Factory: zero address\");\n\n        // Sort tokens so token0 < token1 (by address value)\n        // This ensures getPool(A,B) and getPool(B,A) return the same result\n        (address token0, address token1) = _sortTokens(tokenA, tokenB);\n\n        // Check pool doesn't already exist\n        require(pools[token0][token1] == address(0), \"Factory: pool already exists\");\n\n        // Create LP token name and symbol\n        // In production, you'd use token symbols, but we keep it simple\n        string memory lpName = \"LP Token\";\n        string memory lpSymbol = \"LP\";\n\n        // Deploy new pool contract\n        // The \"new\" keyword deploys a new contract and returns its address\n        LiquidityPool newPool = new LiquidityPool(\n            token0,\n            token1,\n            lpName,\n            lpSymbol\n        );\n\n        pool = address(newPool);\n\n        // Store pool address (both directions for easy lookup)\n        pools[token0][token1] = pool;\n        pools[token1][token0] = pool;\n\n        // Add to array of all pools\n        allPools.push(pool);\n\n        // Emit event\n        emit PoolCreated(token0, token1, pool, allPools.length - 1);\n    }\n\n    // ============ Internal Helpers ============\n\n    /**\n     * @notice Sort two token addresses\n     * @dev Ensures token0 < token1 for consistent mapping keys\n     */\n    function _sortTokens(\n        address tokenA,\n        address tokenB\n    ) internal pure returns (address token0, address token1) {\n        // Compare addresses as numbers\n        // Addresses are basically 160-bit integers\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n}\n"
      },
      "project/contracts/tokens/ERC20Base.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/**\n * @title ERC20Base\n * @notice Abstract base contract implementing the ERC-20 token standard\n * @dev This is an \"abstract\" contract - it cannot be deployed directly.\n *      Other contracts must inherit from it and implement the constructor.\n *\n * ERC-20 is THE standard for fungible tokens on Ethereum. It defines:\n * - How to transfer tokens between addresses\n * - How to check balances\n * - How to allow others to spend your tokens (approve/transferFrom)\n *\n * The approve/transferFrom pattern is CRITICAL for DeFi:\n * 1. User calls approve(spender, amount) to allow a contract to spend their tokens\n * 2. The contract then calls transferFrom(user, recipient, amount) to move tokens\n * This two-step process is how DEXes, lending protocols, etc. work!\n */\nabstract contract ERC20Base {\n    // ============ State Variables ============\n\n    /// @notice Token name (e.g., \"Ethereum\")\n    string public name;\n\n    /// @notice Token symbol (e.g., \"ETH\")\n    string public symbol;\n\n    /// @notice Number of decimals (almost always 18 for ERC-20 tokens)\n    /// @dev 18 decimals means 1 token = 1e18 (1000000000000000000) base units\n    uint8 public constant decimals = 18;\n\n    /// @notice Total supply of tokens in existence\n    uint256 public totalSupply;\n\n    /// @notice Mapping from address to their token balance\n    /// @dev balanceOf[0x123...] returns how many tokens that address owns\n    mapping(address => uint256) public balanceOf;\n\n    /// @notice Nested mapping for allowances: owner => spender => amount\n    /// @dev allowance[owner][spender] = how much spender can spend of owner's tokens\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    // ============ Events ============\n    // Events are logs stored on the blockchain. They're cheap to emit\n    // and can be queried by off-chain applications (like frontends).\n\n    /// @notice Emitted when tokens are transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Emitted when an allowance is set\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    // ============ Constructor ============\n\n    /**\n     * @notice Initialize the token with name and symbol\n     * @param _name The name of the token\n     * @param _symbol The symbol of the token\n     */\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    // ============ External Functions ============\n\n    /**\n     * @notice Transfer tokens to another address\n     * @param to The recipient address\n     * @param amount The amount to transfer (in base units, so 1e18 = 1 token)\n     * @return success Always returns true (reverts on failure)\n     *\n     * @dev This is the simple transfer - you send YOUR tokens to someone else.\n     */\n    function transfer(address to, uint256 amount) external returns (bool) {\n        // Use internal function to do the actual transfer\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n     * @notice Approve another address to spend your tokens\n     * @param spender The address allowed to spend tokens\n     * @param amount The maximum amount they can spend\n     * @return success Always returns true\n     *\n     * @dev WHY IS THIS NEEDED?\n     * Smart contracts can't \"pull\" tokens from your wallet without permission.\n     * When you want to use a DEX:\n     * 1. You first approve() the DEX contract to spend your tokens\n     * 2. Then you call the DEX's swap function\n     * 3. The DEX uses transferFrom() to take your tokens\n     *\n     * This is the \"approve pattern\" - fundamental to all of DeFi!\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        // Store the allowance\n        allowance[msg.sender][spender] = amount;\n\n        // Emit event so off-chain apps can track approvals\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice Transfer tokens on behalf of another address (requires approval)\n     * @param from The address to take tokens from\n     * @param to The address to send tokens to\n     * @param amount The amount to transfer\n     * @return success Always returns true (reverts on failure)\n     *\n     * @dev This is the \"pull\" pattern used by DEXes and other DeFi protocols.\n     * The caller (msg.sender) must have been approved by 'from' to spend >= amount.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool) {\n        // Check that caller has enough allowance\n        uint256 currentAllowance = allowance[from][msg.sender];\n        require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n\n        // Reduce the allowance (prevents spending more than approved)\n        // Using unchecked because we already verified currentAllowance >= amount\n        unchecked {\n            allowance[from][msg.sender] = currentAllowance - amount;\n        }\n\n        // Do the transfer\n        _transfer(from, to, amount);\n\n        return true;\n    }\n\n    // ============ Internal Functions ============\n    // Internal functions can only be called from within this contract\n    // or contracts that inherit from it. They start with underscore by convention.\n\n    /**\n     * @notice Internal function to handle transfers\n     * @dev Checks balances and moves tokens. Used by both transfer() and transferFrom()\n     */\n    function _transfer(address from, address to, uint256 amount) internal {\n        // Safety checks\n        require(from != address(0), \"ERC20: transfer from zero address\");\n        require(to != address(0), \"ERC20: transfer to zero address\");\n        require(balanceOf[from] >= amount, \"ERC20: insufficient balance\");\n\n        // Update balances\n        // unchecked saves gas when we know underflow/overflow can't happen\n        unchecked {\n            balanceOf[from] -= amount;  // Safe: we checked balance above\n            balanceOf[to] += amount;    // Safe: totalSupply is capped\n        }\n\n        // Emit event\n        emit Transfer(from, to, amount);\n    }\n\n    /**\n     * @notice Internal function to create new tokens\n     * @param to The address to receive the new tokens\n     * @param amount The amount to mint\n     * @dev Only callable by child contracts. Increases totalSupply.\n     */\n    function _mint(address to, uint256 amount) internal {\n        require(to != address(0), \"ERC20: mint to zero address\");\n\n        totalSupply += amount;\n        balanceOf[to] += amount;\n\n        // Transfer from address(0) indicates minting (new tokens created)\n        emit Transfer(address(0), to, amount);\n    }\n\n    /**\n     * @notice Internal function to destroy tokens\n     * @param from The address to burn tokens from\n     * @param amount The amount to burn\n     * @dev Only callable by child contracts. Decreases totalSupply.\n     */\n    function _burn(address from, uint256 amount) internal {\n        require(from != address(0), \"ERC20: burn from zero address\");\n        require(balanceOf[from] >= amount, \"ERC20: insufficient balance to burn\");\n\n        unchecked {\n            balanceOf[from] -= amount;\n        }\n        totalSupply -= amount;\n\n        // Transfer to address(0) indicates burning (tokens destroyed)\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
      },
      "project/contracts/tokens/LPToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./ERC20Base.sol\";\n\n/**\n * @title LPToken\n * @notice Liquidity Provider token - represents ownership of pool liquidity\n * @dev Only the pool contract can mint and burn these tokens\n *\n * WHAT ARE LP TOKENS?\n * When you add liquidity to a pool (deposit both tokens), you receive LP tokens.\n * These LP tokens represent YOUR SHARE of the pool.\n *\n * Example:\n * - Pool has 1000 ETH + 2,000,000 USDC (total 1000 LP tokens exist)\n * - You add 100 ETH + 200,000 USDC\n * - You receive 100 LP tokens (10% of pool = 100/1000)\n * - Later, pool grows to 1500 ETH + 3,000,000 USDC from fees\n * - You burn your 100 LP tokens (still 10% of pool)\n * - You get back 150 ETH + 300,000 USDC (profit from fees!)\n *\n * SECURITY:\n * Only the pool contract should be able to mint/burn LP tokens.\n * That's why we have the \"pool\" address and onlyPool modifier.\n */\ncontract LPToken is ERC20Base {\n    /// @notice The pool contract that controls this LP token\n    /// @dev Only this address can call mint() and burn()\n    address public pool;\n\n    /// @notice Restricts function access to only the pool contract\n    modifier onlyPool() {\n        require(msg.sender == pool, \"LPToken: caller is not the pool\");\n        _;\n    }\n\n    /**\n     * @notice Deploy a new LP token\n     * @param _name Token name (e.g., \"TKA-TKB LP\")\n     * @param _symbol Token symbol (e.g., \"TKA-TKB-LP\")\n     *\n     * @dev The deployer (msg.sender) becomes the pool.\n     * This means the LiquidityPool contract deploys this token\n     * and automatically becomes the only address that can mint/burn.\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol\n    ) ERC20Base(_name, _symbol) {\n        // The contract that deploys this LP token becomes the pool\n        pool = msg.sender;\n    }\n\n    /**\n     * @notice Mint new LP tokens (only callable by pool)\n     * @param to Address to receive the LP tokens\n     * @param amount Amount of LP tokens to mint\n     *\n     * @dev Called when users add liquidity to the pool\n     */\n    function mint(address to, uint256 amount) external onlyPool {\n        _mint(to, amount);\n    }\n\n    /**\n     * @notice Burn LP tokens (only callable by pool)\n     * @param from Address to burn LP tokens from\n     * @param amount Amount of LP tokens to burn\n     *\n     * @dev Called when users remove liquidity from the pool\n     */\n    function burn(address from, uint256 amount) external onlyPool {\n        _burn(from, amount);\n    }\n}\n"
      }
    }
  }
}