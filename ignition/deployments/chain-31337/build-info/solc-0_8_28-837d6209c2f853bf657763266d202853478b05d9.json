{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-837d6209c2f853bf657763266d202853478b05d9",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/tokens/SimpleToken.sol": "project/contracts/tokens/SimpleToken.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/tokens/ERC20Base.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/**\n * @title ERC20Base\n * @notice Abstract base contract implementing the ERC-20 token standard\n * @dev This is an \"abstract\" contract - it cannot be deployed directly.\n *      Other contracts must inherit from it and implement the constructor.\n *\n * ERC-20 is THE standard for fungible tokens on Ethereum. It defines:\n * - How to transfer tokens between addresses\n * - How to check balances\n * - How to allow others to spend your tokens (approve/transferFrom)\n *\n * The approve/transferFrom pattern is CRITICAL for DeFi:\n * 1. User calls approve(spender, amount) to allow a contract to spend their tokens\n * 2. The contract then calls transferFrom(user, recipient, amount) to move tokens\n * This two-step process is how DEXes, lending protocols, etc. work!\n */\nabstract contract ERC20Base {\n    // ============ State Variables ============\n\n    /// @notice Token name (e.g., \"Ethereum\")\n    string public name;\n\n    /// @notice Token symbol (e.g., \"ETH\")\n    string public symbol;\n\n    /// @notice Number of decimals (almost always 18 for ERC-20 tokens)\n    /// @dev 18 decimals means 1 token = 1e18 (1000000000000000000) base units\n    uint8 public constant decimals = 18;\n\n    /// @notice Total supply of tokens in existence\n    uint256 public totalSupply;\n\n    /// @notice Mapping from address to their token balance\n    /// @dev balanceOf[0x123...] returns how many tokens that address owns\n    mapping(address => uint256) public balanceOf;\n\n    /// @notice Nested mapping for allowances: owner => spender => amount\n    /// @dev allowance[owner][spender] = how much spender can spend of owner's tokens\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    // ============ Events ============\n    // Events are logs stored on the blockchain. They're cheap to emit\n    // and can be queried by off-chain applications (like frontends).\n\n    /// @notice Emitted when tokens are transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Emitted when an allowance is set\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    // ============ Constructor ============\n\n    /**\n     * @notice Initialize the token with name and symbol\n     * @param _name The name of the token\n     * @param _symbol The symbol of the token\n     */\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    // ============ External Functions ============\n\n    /**\n     * @notice Transfer tokens to another address\n     * @param to The recipient address\n     * @param amount The amount to transfer (in base units, so 1e18 = 1 token)\n     * @return success Always returns true (reverts on failure)\n     *\n     * @dev This is the simple transfer - you send YOUR tokens to someone else.\n     */\n    function transfer(address to, uint256 amount) external returns (bool) {\n        // Use internal function to do the actual transfer\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n     * @notice Approve another address to spend your tokens\n     * @param spender The address allowed to spend tokens\n     * @param amount The maximum amount they can spend\n     * @return success Always returns true\n     *\n     * @dev WHY IS THIS NEEDED?\n     * Smart contracts can't \"pull\" tokens from your wallet without permission.\n     * When you want to use a DEX:\n     * 1. You first approve() the DEX contract to spend your tokens\n     * 2. Then you call the DEX's swap function\n     * 3. The DEX uses transferFrom() to take your tokens\n     *\n     * This is the \"approve pattern\" - fundamental to all of DeFi!\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        // Store the allowance\n        allowance[msg.sender][spender] = amount;\n\n        // Emit event so off-chain apps can track approvals\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice Transfer tokens on behalf of another address (requires approval)\n     * @param from The address to take tokens from\n     * @param to The address to send tokens to\n     * @param amount The amount to transfer\n     * @return success Always returns true (reverts on failure)\n     *\n     * @dev This is the \"pull\" pattern used by DEXes and other DeFi protocols.\n     * The caller (msg.sender) must have been approved by 'from' to spend >= amount.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool) {\n        // Check that caller has enough allowance\n        uint256 currentAllowance = allowance[from][msg.sender];\n        require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n\n        // Reduce the allowance (prevents spending more than approved)\n        // Using unchecked because we already verified currentAllowance >= amount\n        unchecked {\n            allowance[from][msg.sender] = currentAllowance - amount;\n        }\n\n        // Do the transfer\n        _transfer(from, to, amount);\n\n        return true;\n    }\n\n    // ============ Internal Functions ============\n    // Internal functions can only be called from within this contract\n    // or contracts that inherit from it. They start with underscore by convention.\n\n    /**\n     * @notice Internal function to handle transfers\n     * @dev Checks balances and moves tokens. Used by both transfer() and transferFrom()\n     */\n    function _transfer(address from, address to, uint256 amount) internal {\n        // Safety checks\n        require(from != address(0), \"ERC20: transfer from zero address\");\n        require(to != address(0), \"ERC20: transfer to zero address\");\n        require(balanceOf[from] >= amount, \"ERC20: insufficient balance\");\n\n        // Update balances\n        // unchecked saves gas when we know underflow/overflow can't happen\n        unchecked {\n            balanceOf[from] -= amount;  // Safe: we checked balance above\n            balanceOf[to] += amount;    // Safe: totalSupply is capped\n        }\n\n        // Emit event\n        emit Transfer(from, to, amount);\n    }\n\n    /**\n     * @notice Internal function to create new tokens\n     * @param to The address to receive the new tokens\n     * @param amount The amount to mint\n     * @dev Only callable by child contracts. Increases totalSupply.\n     */\n    function _mint(address to, uint256 amount) internal {\n        require(to != address(0), \"ERC20: mint to zero address\");\n\n        totalSupply += amount;\n        balanceOf[to] += amount;\n\n        // Transfer from address(0) indicates minting (new tokens created)\n        emit Transfer(address(0), to, amount);\n    }\n\n    /**\n     * @notice Internal function to destroy tokens\n     * @param from The address to burn tokens from\n     * @param amount The amount to burn\n     * @dev Only callable by child contracts. Decreases totalSupply.\n     */\n    function _burn(address from, uint256 amount) internal {\n        require(from != address(0), \"ERC20: burn from zero address\");\n        require(balanceOf[from] >= amount, \"ERC20: insufficient balance to burn\");\n\n        unchecked {\n            balanceOf[from] -= amount;\n        }\n        totalSupply -= amount;\n\n        // Transfer to address(0) indicates burning (tokens destroyed)\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
      },
      "project/contracts/tokens/SimpleToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./ERC20Base.sol\";\n\n/**\n * @title SimpleToken\n * @notice A simple ERC-20 token for testing purposes\n * @dev Inherits from ERC20Base and mints initial supply to deployer\n *\n * This is a \"concrete\" contract (not abstract) - it CAN be deployed.\n * We use this token for testing our DEX.\n *\n * INHERITANCE:\n * SimpleToken is ERC20Base\n * - SimpleToken gets ALL functions from ERC20Base (transfer, approve, etc.)\n * - SimpleToken can call internal functions like _mint()\n * - We only need to add the constructor and any extra functionality\n */\ncontract SimpleToken is ERC20Base {\n    /**\n     * @notice Deploy a new SimpleToken\n     * @param _name Token name (e.g., \"Token A\")\n     * @param _symbol Token symbol (e.g., \"TKA\")\n     * @param _initialSupply How many tokens to mint (in base units)\n     *\n     * @dev The deployer receives all the initial tokens.\n     * Remember: 1 token with 18 decimals = 1e18 = 1000000000000000000\n     * So if you want 1 million tokens, pass 1_000_000 * 10**18\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 _initialSupply\n    ) ERC20Base(_name, _symbol) {\n        // Mint all initial tokens to whoever deployed the contract\n        // msg.sender = the address that called this constructor\n        _mint(msg.sender, _initialSupply);\n    }\n}\n"
      }
    }
  }
}